---
title: Node JS Event Loop
date: 2019-06-09 15:50:22
tags: 
  - Node.js
  - Javascript 
  - Event Loop
---

Every now and then I see a new blog post about node.js event loop / how it works or an in depth review about the internals, but I never really understood how it reflects to my every day code and how can I leverage it until I dug in myself to Node core. Node.js seems like a simple beast to handle but in reality, there are a lot of layers of abstraction that let you think that, and maybe it is a good thing, but remember, that like everything else in software, it has its tradeoffs.
The purpose of this post is to show you a real picture of how the Node core handles the event loop, what it really is and how it coexists with the JS runtime.
 Lets see a few simple questions and then break them down with examples.
  - What is the event loop in practice:
    - What is the event loop?
    - What are its phases in libuv?
    - What are its phases in Node.js?
    - How is it implemented in practice?
  - Is Node.js really single threaded?
  - Why do we have a thread pool if we already have the event loop that does all the async operations

Now, let's answer the question 1.1: 
> What is the event loop??

From the Node.js website, summarized:
>Node.js is an event-based platform. This means that everything that happens in Node is the reaction to an event. Abstracted away from the developer, the reactions to events are all handled by a library called **libuv**.


> **libuv** is cross-platform support library which was originally written for Node.js. Itâ€™s designed around the event-driven asynchronous I/O model.

> **libuv** provides 2 mechanisms. One is a called an **event loop**, which runs only on one thread (our js thread), and the other mechanism is called a **thread pool**.

It is important to note that the **event loop** and the JS runtime run on the **same** thread and the **thread pool** is initiated with **4** threads.

Answering question 1.2
> What are its phases in libuv?
	
![](/Node-JS-Event-Loop-0/loop_iteration.png)



```c++
int uv_run(uv_loop_t* loop, uv_run_mode mode) {
  int timeout;
  int r;
  int ran_pending;

  r = uv__loop_alive(loop);
  if (!r)
    uv__update_time(loop);

  while (r != 0 && loop->stop_flag == 0) {
    uv__update_time(loop);
    uv__run_timers(loop);
    ran_pending = uv__run_pending(loop);
    uv__run_idle(loop);
    uv__run_prepare(loop);

    timeout = 0;
    if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)
      timeout = uv_backend_timeout(loop);

    uv__io_poll(loop, timeout);
    uv__run_check(loop);
    uv__run_closing_handles(loop);

    if (mode == UV_RUN_ONCE) {
      /* UV_RUN_ONCE implies forward progress: at least one callback must have
       * been invoked when it returns. uv__io_poll() can return without doing
       * I/O (meaning: no callbacks) when its timeout expires - which means we
       * have pending timers that satisfy the forward progress constraint.
       *
       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from
       * the check.
       */
      uv__update_time(loop);
      uv__run_timers(loop);
    }

    r = uv__loop_alive(loop);
    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)
      break;
  }

  /* The if statement lets gcc compile it to a conditional store. Avoids
   * dirtying a cache line.
   */
  if (loop->stop_flag != 0)
    loop->stop_flag = 0;

  return r;
}
```




Now, let's answer the 1st question: 
> Is Node.js single threaded?

Well, as we said previously, the event loop runs on the same thread as the JS runtime, which means, that we have one execution thread, so by definition, **Node.js is single threaded**.

Now that we have established that Node.js is single threaded, Let's look at the second question:
> Why do we have a thread pool if we already have the event loop that does all the async operations

Here, we have to do some explaining of the underlying operating systems, like: Solaris, Windows, Linux, MacOS.

